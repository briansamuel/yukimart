/**
 * Invoice Filter Tests - Playwright Automation Script
 * Tests all filter functionality on the invoice listing page
 */

const { chromium } = require('playwright');

class InvoiceFilterTests {
    constructor() {
        this.browser = null;
        this.page = null;
        this.results = [];
        this.baseUrl = 'http://yukimart.local/admin/invoices';
        this.loginUrl = 'http://yukimart.local/login';
        this.credentials = {
            email: 'yukimart@gmail.com',
            password: '123456'
        };
        this.sessionFile = './session.json';
    }

    async setup() {
        console.log('üöÄ Setting up Invoice Filter Tests...');
        this.browser = await chromium.launch({
            headless: false,
            slowMo: 500 // Slow down for better visibility
        });

        // Create context with persistent session
        const context = await this.browser.newContext({
            viewport: { width: 1920, height: 1080 }
        });

        // Load saved session if exists
        await this.loadSession(context);

        this.page = await context.newPage();

        // Check if already logged in
        await this.page.goto(this.baseUrl);
        await this.page.waitForLoadState('networkidle');

        // If redirected to login, need to authenticate
        if (this.page.url().includes('/login')) {
            console.log('üîê Session expired, need to login...');
            await this.login();
            await this.saveSession(context);
        } else {
            console.log('‚úÖ Session valid, already logged in');
        }

        // Navigate to invoices page
        console.log('üìÑ Navigating to invoices page...');
        await this.page.goto(this.baseUrl);
        await this.page.waitForLoadState('networkidle');

        // Wait for page to load
        console.log('‚è≥ Waiting for invoice data to load...');
        await this.waitForDataLoad();

        console.log('‚úÖ Setup completed');
    }

    async login() {
        console.log('üîê Attempting to login...');

        // Go to correct login page
        await this.page.goto(this.loginUrl);
        await this.page.waitForLoadState('networkidle');

        // Wait for login form
        await this.page.waitForSelector('input[name="email"]', { timeout: 10000 });

        // Fill login form
        console.log('üìù Filling login form...');
        await this.page.fill('input[name="email"]', this.credentials.email);
        await this.page.waitForTimeout(500);
        await this.page.fill('input[name="password"]', this.credentials.password);
        await this.page.waitForTimeout(500);

        // Submit form
        console.log('üöÄ Submitting login form...');
        await Promise.all([
            this.page.waitForNavigation({ waitUntil: 'networkidle' }),
            this.page.click('button[type="submit"]')
        ]);

        // Verify login success
        const currentUrl = this.page.url();
        if (currentUrl.includes('/admin/') && !currentUrl.includes('/login')) {
            console.log('‚úÖ Login successful');
        } else {
            throw new Error(`Login failed - current URL: ${currentUrl}`);
        }
    }

    async saveSession(context) {
        try {
            const fs = require('fs').promises;
            const cookies = await context.cookies();
            const localStorage = await this.page.evaluate(() => {
                return JSON.stringify(localStorage);
            });

            const sessionData = {
                cookies,
                localStorage,
                timestamp: Date.now()
            };

            await fs.writeFile(this.sessionFile, JSON.stringify(sessionData, null, 2));
            console.log('üíæ Session saved');
        } catch (error) {
            console.log('‚ö†Ô∏è Failed to save session:', error.message);
        }
    }

    async loadSession(context) {
        try {
            const fs = require('fs').promises;
            const sessionData = JSON.parse(await fs.readFile(this.sessionFile, 'utf8'));

            // Check if session is not too old (24 hours)
            const maxAge = 24 * 60 * 60 * 1000; // 24 hours
            if (Date.now() - sessionData.timestamp > maxAge) {
                console.log('‚ö†Ô∏è Session expired, will need fresh login');
                return;
            }

            // Restore cookies
            if (sessionData.cookies) {
                await context.addCookies(sessionData.cookies);
                console.log('üç™ Cookies restored');
            }

        } catch (error) {
            console.log('‚ö†Ô∏è No saved session found or failed to load');
        }
    }

    async waitForDataLoad() {
        // Wait for invoice table to load (exclude debug bar)
        await this.page.waitForSelector('table:not(.phpdebugbar-widgets-params) tbody tr', { timeout: 15000 });

        // Wait for loading to complete (check if "ƒêang t·∫£i d·ªØ li·ªáu..." disappears)
        try {
            await this.page.waitForFunction(() => {
                const tables = document.querySelectorAll('table:not(.phpdebugbar-widgets-params)');
                for (const table of tables) {
                    const loadingText = table.querySelector('tbody tr td');
                    if (loadingText && !loadingText.textContent.includes('ƒêang t·∫£i d·ªØ li·ªáu')) {
                        return true;
                    }
                }
                return false;
            }, { timeout: 10000 });
        } catch (e) {
            console.log('Loading check timeout, proceeding...');
        }

        await this.page.waitForTimeout(2000); // Additional wait for AJAX
    }

    async getResultCount() {
        // Look for pagination info text
        const selectors = [
            'text="Hi·ªÉn th·ªã"',
            ':has-text("k·∫øt qu·∫£")',
            '.dataTables_info',
            '.pagination-info',
            '.table-info'
        ];

        for (const selector of selectors) {
            try {
                const element = await this.page.locator(selector).first();
                if (await element.isVisible()) {
                    const text = await element.textContent();
                    const match = text?.match(/(\d+)\s+k·∫øt qu·∫£/);
                    if (match) return parseInt(match[1]);
                }
            } catch (e) {
                continue;
            }
        }

        // Fallback: count table rows (exclude debug bar)
        const rows = await this.page.locator('table:not(.phpdebugbar-widgets-params) tbody tr').count();
        return rows > 0 && !(await this.page.locator('table:not(.phpdebugbar-widgets-params) tbody tr:has-text("ƒêang t·∫£i")').count()) ? rows : 0;
    }

    async captureNetworkRequest() {
        return new Promise((resolve) => {
            this.page.once('request', (request) => {
                if (request.url().includes('/ajax')) {
                    const url = new URL(request.url());
                    resolve(Object.fromEntries(url.searchParams));
                }
            });
        });
    }

    // Test F01: Time Filter - "Th√°ng n√†y"
    async testTimeFilterThisMonth() {
        console.log('üß™ Testing F01: Time Filter - Th√°ng n√†y');
        
        try {
            // Ensure "Th√°ng n√†y" is selected (should be default)
            const thisMonthRadio = await this.page.locator('input[type="radio"][value="this_month"], input[type="radio"]:has-text("Th√°ng n√†y")').first();
            await thisMonthRadio.check();
            
            // Wait for AJAX request
            const requestPromise = this.captureNetworkRequest();
            await this.page.waitForTimeout(1000);
            const params = await requestPromise.catch(() => ({}));
            
            await this.waitForDataLoad();
            const resultCount = await this.getResultCount();
            
            this.results.push({
                id: 'F01',
                name: 'Time Filter - Th√°ng n√†y',
                status: 'PASSED',
                details: `Filter applied, ${resultCount} results, params: ${JSON.stringify(params)}`
            });
            
            console.log('‚úÖ F01 PASSED');
        } catch (error) {
            this.results.push({
                id: 'F01',
                name: 'Time Filter - Th√°ng n√†y',
                status: 'FAILED',
                details: `Error: ${error.message}`
            });
            console.log('‚ùå F01 FAILED:', error.message);
        }
    }

    // Test F02: Time Filter - "T√πy ch·ªânh"
    async testTimeFilterCustom() {
        console.log('üß™ Testing F02: Time Filter - T√πy ch·ªânh');
        
        try {
            // Click "T√πy ch·ªânh" radio
            const customRadio = await this.page.locator('input[type="radio"][value="custom"], input[type="radio"]:has-text("T√πy ch·ªânh")').first();
            await customRadio.check();
            
            // Check if date picker appears
            await this.page.waitForTimeout(1000);
            const datePickerVisible = await this.page.isVisible('.date-range-picker, input[type="date"], .flatpickr-input');
            
            this.results.push({
                id: 'F02',
                name: 'Time Filter - T√πy ch·ªânh',
                status: datePickerVisible ? 'PASSED' : 'FAILED',
                details: `Custom radio checked, date picker visible: ${datePickerVisible}`
            });
            
            console.log(datePickerVisible ? '‚úÖ F02 PASSED' : '‚ùå F02 FAILED');
        } catch (error) {
            this.results.push({
                id: 'F02',
                name: 'Time Filter - T√πy ch·ªânh',
                status: 'FAILED',
                details: `Error: ${error.message}`
            });
            console.log('‚ùå F02 FAILED:', error.message);
        }
    }

    // Test F03: Status Filter - "ƒêang x·ª≠ l√Ω"
    async testStatusFilterProcessing() {
        console.log('üß™ Testing F03: Status Filter - ƒêang x·ª≠ l√Ω');
        
        try {
            // Uncheck all status checkboxes first
            await this.page.uncheck('input[type="checkbox"]:has-text("Ho√†n th√†nh")').catch(() => {});
            
            // Check only "ƒêang x·ª≠ l√Ω"
            const processingCheckbox = await this.page.locator('input[type="checkbox"]:has-text("ƒêang x·ª≠ l√Ω")').first();
            await processingCheckbox.check();
            
            const requestPromise = this.captureNetworkRequest();
            await this.page.waitForTimeout(2000);
            const params = await requestPromise.catch(() => ({}));
            
            await this.waitForDataLoad();
            const resultCount = await this.getResultCount();
            
            // Verify all results have "ƒêang x·ª≠ l√Ω" status
            const statusCells = await this.page.locator('table tbody tr td:has-text("ƒêang x·ª≠ l√Ω")').count();
            const totalRows = await this.page.locator('table tbody tr').count();
            
            const allProcessing = statusCells === totalRows;
            
            this.results.push({
                id: 'F03',
                name: 'Status Filter - ƒêang x·ª≠ l√Ω',
                status: allProcessing ? 'PASSED' : 'FAILED',
                details: `${resultCount} results, ${statusCells}/${totalRows} rows with "ƒêang x·ª≠ l√Ω" status`
            });
            
            console.log(allProcessing ? '‚úÖ F03 PASSED' : '‚ùå F03 FAILED');
        } catch (error) {
            this.results.push({
                id: 'F03',
                name: 'Status Filter - ƒêang x·ª≠ l√Ω',
                status: 'FAILED',
                details: `Error: ${error.message}`
            });
            console.log('‚ùå F03 FAILED:', error.message);
        }
    }

    // Test F04: Status Filter - "Ho√†n th√†nh"
    async testStatusFilterCompleted() {
        console.log('üß™ Testing F04: Status Filter - Ho√†n th√†nh');
        
        try {
            // Uncheck "ƒêang x·ª≠ l√Ω" and check "Ho√†n th√†nh"
            await this.page.uncheck('input[type="checkbox"]:has-text("ƒêang x·ª≠ l√Ω")').catch(() => {});
            
            const completedCheckbox = await this.page.locator('input[type="checkbox"]:has-text("Ho√†n th√†nh")').first();
            await completedCheckbox.check();
            
            const requestPromise = this.captureNetworkRequest();
            await this.page.waitForTimeout(2000);
            const params = await requestPromise.catch(() => ({}));
            
            await this.waitForDataLoad();
            const resultCount = await this.getResultCount();
            
            // Verify all results have "Ho√†n th√†nh" status
            const statusCells = await this.page.locator('table tbody tr td:has-text("Ho√†n th√†nh")').count();
            const totalRows = await this.page.locator('table tbody tr').count();
            
            const allCompleted = statusCells === totalRows;
            
            this.results.push({
                id: 'F04',
                name: 'Status Filter - Ho√†n th√†nh',
                status: allCompleted ? 'PASSED' : 'FAILED',
                details: `${resultCount} results, ${statusCells}/${totalRows} rows with "Ho√†n th√†nh" status`
            });
            
            console.log(allCompleted ? '‚úÖ F04 PASSED' : '‚ùå F04 FAILED');
        } catch (error) {
            this.results.push({
                id: 'F04',
                name: 'Status Filter - Ho√†n th√†nh',
                status: 'FAILED',
                details: `Error: ${error.message}`
            });
            console.log('‚ùå F04 FAILED:', error.message);
        }
    }

    // Test F05: Multiple Status Filter
    async testMultipleStatusFilter() {
        console.log('üß™ Testing F05: Multiple Status Filter');
        
        try {
            // Check both "ƒêang x·ª≠ l√Ω" and "Ho√†n th√†nh"
            await this.page.check('input[type="checkbox"]:has-text("ƒêang x·ª≠ l√Ω")');
            await this.page.check('input[type="checkbox"]:has-text("Ho√†n th√†nh")');
            
            const requestPromise = this.captureNetworkRequest();
            await this.page.waitForTimeout(2000);
            const params = await requestPromise.catch(() => ({}));
            
            await this.waitForDataLoad();
            const resultCount = await this.getResultCount();
            
            // Verify results contain both statuses
            const processingCells = await this.page.locator('table tbody tr td:has-text("ƒêang x·ª≠ l√Ω")').count();
            const completedCells = await this.page.locator('table tbody tr td:has-text("Ho√†n th√†nh")').count();
            const totalRows = await this.page.locator('table tbody tr').count();
            
            const validResults = (processingCells + completedCells) === totalRows;
            
            this.results.push({
                id: 'F05',
                name: 'Multiple Status Filter',
                status: validResults ? 'PASSED' : 'FAILED',
                details: `${resultCount} results, ${processingCells} processing + ${completedCells} completed = ${totalRows} total`
            });
            
            console.log(validResults ? '‚úÖ F05 PASSED' : '‚ùå F05 FAILED');
        } catch (error) {
            this.results.push({
                id: 'F05',
                name: 'Multiple Status Filter',
                status: 'FAILED',
                details: `Error: ${error.message}`
            });
            console.log('‚ùå F05 FAILED:', error.message);
        }
    }

    // Test F06: Creator Filter
    async testCreatorFilter() {
        console.log('üß™ Testing F06: Creator Filter');

        try {
            // Click creator dropdown
            const creatorDropdown = await this.page.locator('select:has-text("Ch·ªçn ng∆∞·ªùi t·∫°o"), .select2-container:has-text("Ch·ªçn ng∆∞·ªùi t·∫°o")').first();
            await creatorDropdown.click();
            await this.page.waitForTimeout(1000);

            // Check if dropdown options are visible
            const optionsVisible = await this.page.isVisible('.select2-results, option');

            this.results.push({
                id: 'F06',
                name: 'Creator Filter Dropdown',
                status: optionsVisible ? 'PASSED' : 'FAILED',
                details: `Creator dropdown opened, options visible: ${optionsVisible}`
            });

            console.log(optionsVisible ? '‚úÖ F06 PASSED' : '‚ùå F06 FAILED');
        } catch (error) {
            this.results.push({
                id: 'F06',
                name: 'Creator Filter Dropdown',
                status: 'FAILED',
                details: `Error: ${error.message}`
            });
            console.log('‚ùå F06 FAILED:', error.message);
        }
    }

    // Test F07: Seller Filter
    async testSellerFilter() {
        console.log('üß™ Testing F07: Seller Filter');

        try {
            // Click seller dropdown
            const sellerDropdown = await this.page.locator('select:has-text("Ch·ªçn ng∆∞·ªùi b√°n"), .select2-container:has-text("Ch·ªçn ng∆∞·ªùi b√°n")').first();
            await sellerDropdown.click();
            await this.page.waitForTimeout(1000);

            // Check if dropdown options are visible
            const optionsVisible = await this.page.isVisible('.select2-results, option');

            this.results.push({
                id: 'F07',
                name: 'Seller Filter Dropdown',
                status: optionsVisible ? 'PASSED' : 'FAILED',
                details: `Seller dropdown opened, options visible: ${optionsVisible}`
            });

            console.log(optionsVisible ? '‚úÖ F07 PASSED' : '‚ùå F07 FAILED');
        } catch (error) {
            this.results.push({
                id: 'F07',
                name: 'Seller Filter Dropdown',
                status: 'FAILED',
                details: `Error: ${error.message}`
            });
            console.log('‚ùå F07 FAILED:', error.message);
        }
    }

    // Test F08: Delivery Status Filter
    async testDeliveryStatusFilter() {
        console.log('üß™ Testing F08: Delivery Status Filter');

        try {
            // Check "Ch·ªù x·ª≠ l√Ω" delivery status
            const pendingCheckbox = await this.page.locator('input[type="checkbox"]:has-text("Ch·ªù x·ª≠ l√Ω")').first();
            await pendingCheckbox.check();

            const requestPromise = this.captureNetworkRequest();
            await this.page.waitForTimeout(2000);
            const params = await requestPromise.catch(() => ({}));

            await this.waitForDataLoad();
            const resultCount = await this.getResultCount();

            this.results.push({
                id: 'F08',
                name: 'Delivery Status Filter',
                status: 'PASSED',
                details: `Delivery status filter applied, ${resultCount} results`
            });

            console.log('‚úÖ F08 PASSED');
        } catch (error) {
            this.results.push({
                id: 'F08',
                name: 'Delivery Status Filter',
                status: 'FAILED',
                details: `Error: ${error.message}`
            });
            console.log('‚ùå F08 FAILED:', error.message);
        }
    }

    // Test F09: Sales Channel Filter
    async testSalesChannelFilter() {
        console.log('üß™ Testing F09: Sales Channel Filter');

        try {
            // Type in sales channel input
            const channelInput = await this.page.locator('input:has-text("Ch·ªçn k√™nh b√°n"), input[placeholder*="k√™nh b√°n"]').first();
            await channelInput.fill('C·ª≠a h√†ng');

            const requestPromise = this.captureNetworkRequest();
            await this.page.waitForTimeout(2000);
            const params = await requestPromise.catch(() => ({}));

            await this.waitForDataLoad();
            const resultCount = await this.getResultCount();

            this.results.push({
                id: 'F09',
                name: 'Sales Channel Filter',
                status: 'PASSED',
                details: `Sales channel filter applied, ${resultCount} results`
            });

            console.log('‚úÖ F09 PASSED');
        } catch (error) {
            this.results.push({
                id: 'F09',
                name: 'Sales Channel Filter',
                status: 'FAILED',
                details: `Error: ${error.message}`
            });
            console.log('‚ùå F09 FAILED:', error.message);
        }
    }

    // Test F10: Reset All Filters
    async testResetAllFilters() {
        console.log('üß™ Testing F10: Reset All Filters');

        try {
            // Reset to default state
            await this.page.check('input[type="radio"]:has-text("Th√°ng n√†y")');
            await this.page.check('input[type="checkbox"]:has-text("ƒêang x·ª≠ l√Ω")');
            await this.page.check('input[type="checkbox"]:has-text("Ho√†n th√†nh")');

            // Clear other filters
            await this.page.uncheck('input[type="checkbox"]:has-text("Ch·ªù x·ª≠ l√Ω")').catch(() => {});

            const requestPromise = this.captureNetworkRequest();
            await this.page.waitForTimeout(2000);
            const params = await requestPromise.catch(() => ({}));

            await this.waitForDataLoad();
            const resultCount = await this.getResultCount();

            this.results.push({
                id: 'F10',
                name: 'Reset All Filters',
                status: 'PASSED',
                details: `Filters reset, ${resultCount} results returned to default state`
            });

            console.log('‚úÖ F10 PASSED');
        } catch (error) {
            this.results.push({
                id: 'F10',
                name: 'Reset All Filters',
                status: 'FAILED',
                details: `Error: ${error.message}`
            });
            console.log('‚ùå F10 FAILED:', error.message);
        }
    }

    async runAllTests() {
        console.log('üéØ Starting Invoice Filter Tests...\n');

        await this.setup();

        // Run all filter tests
        await this.testTimeFilterThisMonth();
        await this.testTimeFilterCustom();
        await this.testStatusFilterProcessing();
        await this.testStatusFilterCompleted();
        await this.testMultipleStatusFilter();
        await this.testCreatorFilter();
        await this.testSellerFilter();
        await this.testDeliveryStatusFilter();
        await this.testSalesChannelFilter();
        await this.testResetAllFilters();

        // Generate report
        this.generateReport();

        await this.teardown();
    }

    generateReport() {
        console.log('\nüìä FILTER TESTS REPORT');
        console.log('========================');
        
        let passed = 0;
        let failed = 0;
        
        this.results.forEach(result => {
            const status = result.status === 'PASSED' ? '‚úÖ' : '‚ùå';
            console.log(`${status} ${result.id}: ${result.name}`);
            console.log(`   ${result.details}\n`);
            
            if (result.status === 'PASSED') passed++;
            else failed++;
        });
        
        console.log(`üìà SUMMARY: ${passed}/${passed + failed} tests passed (${Math.round(passed/(passed + failed)*100)}%)`);
        
        // Save results to file
        const reportContent = this.results.map(r => 
            `| ${r.id} | ${r.name} | ${r.status === 'PASSED' ? '‚úÖ PASSED' : '‚ùå FAILED'} | ${r.details} |`
        ).join('\n');
        
        console.log('\nüìù Report saved to results');
        return { passed, failed, total: passed + failed, results: this.results };
    }

    async teardown() {
        if (this.page && this.browser) {
            // Save session before closing
            const context = this.page.context();
            await this.saveSession(context);
            await this.browser.close();
        }
        console.log('üèÅ Tests completed');
    }
}

// Run tests if called directly
if (require.main === module) {
    const tests = new InvoiceFilterTests();
    tests.runAllTests().catch(console.error);
}

module.exports = InvoiceFilterTests;
